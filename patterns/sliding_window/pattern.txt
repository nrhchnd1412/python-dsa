ğŸ”¹ Pattern 1: Fixed-size Sliding Window
Window size is given/fixed. You just move the window forward by 1 each time.

ğŸ”¸ Common Use-Cases:
Maximum/Minimum sum or average of k elements

Basic frequency counts

ğŸ”¸ Problems:
Maximum Sum Subarray of Size K â€“ [LC Easy]

Maximum Average Subarray I â€“ [LC 643]

Find the Kth Largest Sum of a Subarray â€“ [Hard] (variation)

Max Consecutive Ones III (or II if no flips) â€“ [LC 1004 / 487]

Number of Subarrays of Size K and Average â‰¥ Threshold â€“ [LC 1343]

ğŸ”¹ Pattern 2: Variable-size / Shrinking Sliding Window
Window size is dynamic, and you shrink from the left to satisfy a condition.

ğŸ”¸ Common Use-Cases:
Substrings/subarrays with sum or character frequency constraints

Minimizing length

ğŸ”¸ Problems:
Minimum Size Subarray Sum â€“ [LC 209]

Longest Substring Without Repeating Characters â€“ [LC 3]

Longest Substring with At Most K Distinct Characters â€“ [LC 340]

Fruit Into Baskets â€“ [LC 904]

Longest Subarray with Sum â‰¤ K â€“ [Binary search + prefix sum + sliding window]

ğŸ”¹ Pattern 3: Character/Frequency Count in Window
Maintain frequency maps for character counts in current window. Often used with hashmaps.

ğŸ”¸ Common Use-Cases:
Anagrams

Matching permutations

Frequency-based window matches

ğŸ”¸ Problems:
Permutation in String â€“ [LC 567]

Minimum Window Substring â€“ [LC 76]

Find All Anagrams in a String â€“ [LC 438]

Longest Repeating Character Replacement â€“ [LC 424]

Sliding Window Maximum â€“ [LC 239] (Use deque for optimization)

ğŸ”¹ Pattern 4: Monotonic Queue / Deque Based
Used when you need to maintain a maximum or minimum within the window in O(1) time.

ğŸ”¸ Common Use-Cases:
Maximum in current window

Minimums for stock span or temperatures

ğŸ”¸ Problems:
Sliding Window Maximum â€“ [LC 239]

Shortest Subarray with Sum â‰¥ K â€“ [LC 862]

Daily Temperatures â€“ [LC 739] (Stack variant)

Sum of Min and Max of all Subarrays of size K â€“ [Custom Pattern]

ğŸ”¹ Pattern 5: Binary Search + Sliding Window
When finding optimal window size or minimizing/maximizing condition with binary search.

ğŸ”¸ Problems:
Minimum Number of Days to Make m Bouquets â€“ [LC 1482]

Longest Subarray with Absolute Diff â‰¤ Limit â€“ [LC 1438]

Longest Substring with At Most K Distinct Characters â€“ [LC 340]

ğŸ”¹ Pattern 6: Two Pointer (Sliding Window Style)
Use two pointers to extend/shrink window, often without maintaining an explicit window structure.

ğŸ”¸ Problems:
Subarray Product Less Than K â€“ [LC 713]

Count Number of Nice Subarrays (Odd Count) â€“ [LC 1248]

Longest Mountain in Array â€“ [LC 845]

Continuous Subarray Sum â€“ [LC 523]

Max Consecutive Ones II â€“ [LC 487]

ğŸ”¹ Pattern 7: Count of Subarrays Matching Condition
Count how many subarrays satisfy a condition using inclusion-exclusion.

ğŸ”¸ Problems:
Count Number of Substrings Containing All Three Characters â€“ [LC 1358]

Number of Substrings with Exactly K Distinct Characters â€“ [LC Hard Variant]

Subarrays with K Different Integers â€“ [LC 992]

ğŸ”¹ Pattern 8: Sliding Window with Heaps
Used to keep track of median, or dynamic k-th largest/smallest elements.

ğŸ”¸ Problems:
Sliding Window Median â€“ [LC 480]

Median of Two Sorted Arrays â€“ [LC 4] (Binary Search but sliding window logic helps)

ğŸ”¹ Bonus Tips to Recognize Patterns:
Pattern	Keywords to Look For in Problem
Fixed-size	â€œof size kâ€, â€œlength kâ€
Shrinking window	â€œminimum lengthâ€, â€œlongest subarrayâ€
Frequency match	â€œpermutationâ€, â€œanagramâ€, â€œsubstring with same charactersâ€
Monotonic deque	â€œmax/min in windowâ€, â€œsliding maxâ€
Two pointers	â€œsubarray with product/sumâ€, â€œexactly kâ€
Heaps + sliding	â€œmedianâ€, â€œk-th element in windowâ€